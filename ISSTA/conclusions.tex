\section{Conclusions and Future Work}

Unexpected nondeterminism of software systems frustrates users,
whether they be humans or (more importantly) other software systems.
Nondeterminism is even more pernicious in software testing,
frustrating debugging efforts (Heisenbugs \cite{Heisenbug} and
Mandelbugs \cite{GrottkeBugs,FaultTriggers} are widely loathed), and
leading to the costly problem of flaky tests
\cite{miccoflaky,listfieldtestanalysis}.
This paper proposes a formulation of types of nondeterminism, and a
practical approach to using automated test generation to detect and understand
nondeterminism, especially in the library code that underlies most
systems. In addition to traditional \emph{horizontal} nondeterminism, we introduce
the concept of \emph{vertical} nondeterminism bugs, and show their
additional specification power compared to a
strong differential testing harness.  
\begin{comment}
We implemented our approach in the
TSTL automated test generation system for Python, and demonstrated the
simplicity and utility of the approach on real-world examples.
\end{comment}

As future work, we would like to support the automatic detection of opaque
values; if a value (e.g., a timestamp) is different in \emph{every}
trace, it is likely opaque.  This would make
testing libraries mixing deterministic and nondeterministic
behavior, e.g. cryptographic libraries, much easier. Similarly, for
vertical nondeterminism, we would like to
automatically identify usually-idempotent operations.
%We would also like to lower the cost
%of checking process nondeterminism, perhaps by using methods taken in
%AFL \cite{aflfuzz} to avoid high startup costs for test executions.
Finally, we are interested in using test decomposition
\cite{Composition} to more isolate, understand, and mitigate
nondeterminism in unit tests, and to mitigate flaky tests.
Reliable detection of nondeterminism is a critical tool in making such
an approach efficient and reliable.

\begin{comment}
Finally, it would be useful to implement versions of our formalisms in
test generation tools for other languages with a suitable notion of
action.  For example, the DeepState
\cite{DeepState,DeepStateTutorial,deepstaterepo} tool for
property-based fuzzing and symbolic-execution of C and C++ code defines
actions that are choices between C++ lambdas in a test harness,
produced by a nondeterminism operator, {\tt OneOf}.
Adding annotations of visible state (perhaps simply in the form of
blocks of address ranges in memory, a method often suitable for C and
C++ code) would make it possible to search for unexpected nondeterminism in
critical C and C++ libraries.

{\scriptsize {\bf Acknowledgments:}  The authors would like to thank John Micco,
Jeff Listfield, and Celal Ziftci at Google, for discussion of
flaky tests, Andreas Zeller and David R. MacIver for discussion of the
problem of probabilistic delta-debugging, and Chris
Colohan for discussion of sources of process-based nondeterminism.}
\end{comment}
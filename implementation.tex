\section{Implementation}

\subsection{Sources of Nondeterminism in Practice}

\subsubsection{Process-Based Nondeterminism}

\label{sec:pnondet}

Some sources of nondeterminism require executing a test in a new
process environment, because the source is inherently tied to the
process environment.

Address Space Layout Randomization (ASLR) \cite{ASLR}  is probably the most
important source of nondeterminism that arises (only) from change in
process.  ASLR scrambles the layout of 

Different CPU.

This is a simple, clean example
of a problem that appeared in numerous Python programs when Python
version 3.3 introduced automatic random salting of hashes (see Section
\ref{sec:pnondet} per-process,
in order to mitigate hash-based denial of service attacks
\cite{denial}.  Until version 3.6 this not only resulted in changes in
exact hash values, but in the order of iteration on
dictionaries\footnote{In version 3.6, the default dictionary
  implementation became an ordered dictionary with consistent
  iteration, though actual hashes remained nondeterministic.}.  While
relatively few programs relied on exact hash values, many implicitly
relied on them in that they only functioned correctly with a
predictable order for dictionary iteration across processess.

\subsection{Implementing Nondeterminism Detection}

We implemented our approach in the TSTL \cite{NFM15} system.

Because TSTL supports differential testing \cite{tstlsttt}, horizontal
nondeterminism detection can technically be implemented simply by
declaring a system to be its own reference, using TSTL's notation for
differential testing.  However, such an approach requires some effort
on the part of the user to control which values are checked for
equivalence, and does not easily support injecting timing differences,
or using a new process, in checking the behavior.



Because TSTL has an interface to afl \cite{aflfuzz}, we can even use
afl's sophisticated heuristics to perform very thorough, week-long
checks for nondeterminism, using strategies built to find subtle
security vulnerabilities in C programs.
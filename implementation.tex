\section{Implementation}

\subsection{Sources of Nondeterminism in Practice}

\subsubsection{Process-Based Nondeterminism}

\label{sec:pnondet}

Some sources of nondeterminism require executing a test in a new
process environment, because the source is inherently tied to the
process environment.

Address Space Layout Randomization (ASLR) \cite{ASLR}  is probably the most
important source of nondeterminism that arises (only) from change in
process.  ASLR scrambles the layout of memory of the process in which
an executable runs in order to make it
harder to exploit memory-safety vulnerabilities.  As a side effect, it
means that a test that, in some circumstances, causes a crash, may at
other times not fail at all.

Different CPU.

Another example of process-based nondeterminism was discovered by numerous Python programs when Python
version 3.3 introduced automatic random salting of hashes (see Section
\ref{sec:pnondet} per-process,
in order to mitigate hash-based denial of service attacks
\cite{denial}.  Until version 3.6 this not only resulted in changes in
exact hash values, but in the order of iteration on
dictionaries\footnote{In version 3.6, the default dictionary
  implementation became an ordered dictionary with consistent
  iteration, though actual hashes remained nondeterministic.}.  While
relatively few programs relied on exact hash values, many implicitly
relied on them in that they only functioned correctly with a
predictable order for dictionary iteration across processess.  Testing
Python code for nondeterminism based on this hash seed requires
running in a new process:  Python does not allow changing the salt, since changing hash values on-the-fly would
break all existing dictionaries and other structures relying on hashing.

\subsection{Implementing Nondeterminism Detection}

We implemented our approach in the TSTL \cite{NFM15} system.

Because TSTL supports differential testing \cite{tstlsttt}, horizontal
nondeterminism detection can technically be implemented simply by
declaring a system to be its own reference, using TSTL's notation for
differential testing.  However, such an approach requires some effort
on the part of the user to control which values are checked for
equivalence, and does not easily support injecting timing differences,
or using a new process, in checking the behavior.



Because TSTL has an interface to afl \cite{aflfuzz}, we can even use
afl's sophisticated heuristics to perform very thorough, week-long
checks for nondeterminism, using strategies built to find subtle
security vulnerabilities in C programs.